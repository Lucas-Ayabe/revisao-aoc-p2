<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Revisão para a P2 de AOC</title>
        <link
            href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,600;1,400&family=Poppins:wght@400;500&display=swap"
            rel="stylesheet"
        />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            html,
            body {
                font-family: "Poppins", sans-serif;
            }

            h1 {
                font-size: 3.5em;
                font-family: "Playfair Display", serif;
                line-height: 1;
                font-weight: 500;
                margin-top: .5em;
            }

            h2 {
                font-weight: 500;
                font-size: 1.5em;
                line-height: 1;
            }

            h1, h2 {
                margin-bottom: 1em;
            }

            h3 {
                font-size: 1em;
            }

            section > h3 + p {
                margin-top: 0;
            }

            ul {
                padding-left: 2ch;
            }

            ul ol {
                padding-left: 2ch;
            }

            ol > li {
                padding-left: 1ch;
            }

            li + li {
                margin-top: .25em;
            }

            ul+ p, li + p {
                margin-top: 1em;
                margin-bottom: 1em;
            }

            p, span, li {
                line-height: 1.5;
            }

            section {
                border: 1px solid rgba(0, 0, 0, .2);
                padding: 10px;
                border-radius: 4px;
            }

            @media screen and (min-width: 600px) {
                section {
                    padding: 25px;
                }
            }

            section + section {
                margin-top: 2em;
            }

            section > * + * {
                margin-top: 1em;
            }

            b {
                font-weight: 600;
            }

            .container {
                max-width: 100%;
                padding-left: 10px;
                padding-right: 10px;
                margin-left: auto;
                margin-right: auto;
            }

            @media screen and (min-width: 768px) {
                .container {
                    padding-left: 20px;
                    padding-right: 20px;
                    max-width: 756px;
                }
            }

            @media screen and (min-width: 1024px) {
                .container {
                    max-width: 960px;
                }
            }

            @media screen and (min-width: 1200px) {
                .container {
                    max-width: 1140px;
                }
            }
        </style>
    </head>
    <body>
        <article class="container">
            <h1>Revisão para a P2 de AOC</h1>
            
            <section>
                <h2>1 – Explique Set de Instruções, com seus elementos.</h2>
                <p>
                    É a coleção de diferentes instruções que o processador pode
                    executar. Seus elementos são:
                </p>

                <ul>
                    <li>
                        <b>Op code (código de operação):</b> Especifica a operação à ser realizado;
                    </li>
                    <li>
                        <b>Referência à operando fonte:</b> A operação pode envolver um ou mais operandos fontes, ou seja, operandos que são entradas para operação;
                    </li>
                    <li>
                        <b>Referência à operando destino:</b> A operação pode produzir um resultado;
                    </li>
                    <li>
                        <b>Referência à próxima instrução:</b> Diz ao processador onde buscar a próxima instrução após o término da instrução em execução.</li>
                    </li>
                </ul>
            </section>
            <section>
                <h2>
                    2 – Explique a forma que uma instrução pode ser
                    representada, de acordo com os tipos possíveis de
                    processador.
                </h2>
                <p>No computador cada instrução é representada por uma sequência de bits. A instrução é dividida em campos correspondentes aos elementos constituintes de instrução. Os op codes são representados por abreviações, chamadas mnemônicos, que indicam a operação. Ex:</p>
                
                <ul>
                    <li>
                        Add: adiciona; 
                    </li>
                    <li>
                        sub: subtrai; 
                    </li>
                    <li>
                        mul: multiplica; 
                    </li>
                    <li>
                        div: divide; 
                    </li>
                    <li>
                        load: carrega; 
                    </li>
                    <li>
                        stor: armazena;
                    </li>
                </ul>
                
                <h3>Exemplos de instruções para processadores com 3 endereços:</h3> 
                <p>Operando 1, operando 2, resultado: sub y,a,b</p>
                
                <h3>Exemplos de instruções para processadores com 2 endereços:</h3> 
                <p>Neste caso, um endereço realiza trabalho duplo, como operando e como resultado: a=a+b (move y,a // add y,b)</p>

                <h3>Exemplos de instruções para processadores com 1 endereço:</h3> 
                <p>Este é o caso mais simples e para que funcione, um segundo endereço precisa ser implícito, sendo este endereço, um registrador do processador, conhecido como acumulador (AC). O acumulador contem um dos operandos e é usado para armazenar o resultado: Load d, mpy e, add c (ac=d, ac=ac*e, ac=ac+c).</p>
                
                <h3>Exemplos de instruções para processadores com nenhum endereço:</h3> 
                <p>Existem também os casos dos processadores com zero endereços para algumas instruções, que se aplicam a uma organização de memória especial, chamada de pilha.</p>
            </section>
            <section>
                <h2>3 – Explique tipo de dados e qual sua relevância.</h2>
                <p>Tipo de dados é a representação computacional de algo do mundo real, usualmente em linguagens de alto nível temos os tipos primitivos como: </p>
                <ul>
                    <li>String(caractere)</li>
                    <li>Integer(inteiro)</li>
                    <li>Float(número de ponto flutuante ou real)</li>
                    <li>Boolean(booleano ou lógico)</li>
                </ul>

                <p>E em assembly podemos ter tipos como: </p>
                
                <ul>
                    <li>Geral: locais de byte, word (16 bits), palavras duplas (32bits), quatro palavras (64 bits) e quatro palavras duplas (128bits) com conteúdo binário arbitrário.</li>
                    
                    <li>Números inteiros: Um valor binário com sinal, contido em um byte, palavra ou palavras duplas, usando a representação de complemento a dois. Interpretado como campo de bit ou inteiro;</li>

                    <li>Números ordinais: Um inteiro sem sinal contido em um byte, palavra ou palavras duplas;</li>
                    
                    <li>Números em BCD (Binary coded decimal) (BCD) não agrupado: uma representação de um dígito BCD no intervalo de 0 a 9, com um dígito em cada byte;</li>

                    <li>Agrupado BCD: Representação de byte agrupado de dois dígitos BCD; valor no intervalo de 0 a 99;</li>

                    <li>Ponteiro near: Um endereço efetivo de 16, 32 ou 64 bits, que representa o deslocamento dentro de um segmento. Usado para todos os ponteiros em uma memória não segmentada e para referências dentro de um segmento em uma memória segmentada.</li>

                    <li>Ponteiro far: são usados para referência à memória em um modelo de memória segmentado, onde a identidade de um segmento sendo acessado precisa ser especificada explicitamente;</li>

                    <li>Campo de bits: Uma sequência contigua de bits, contendo de zero a 232 - 1 bits.</li>

                    <li>Cadeia de bytes: Uma sequência contigua de bytes, palavras ou doublewords, contendo de zero a 232 - 1 bytes.</li>

                    <li>Ponto flutuante: ((Expoente)(significado) - precisão simples: 32 bits, sendo 22 bits para o significado, 8 bits para o expoente e um para o sinal. Precisão dupla: 64 bits, sendo 52 bits para o significado, 11 bits para o expoente e um para o sinal. Ponto flutuante de precisão dupla extendida: 80 bits, sendo 63 bits para o significado, 1 bit indicando bit de inteiro, 16 bits indicando o expoente e 1 bit de sinal.</li>

                    <li>SIMD agrupada (do inglês single instruction , multiple data \u2013 única instrução, múltiplos dados): Tipos de dados de 64 a 128bits.</li>
                </ul>   

                <p>Os tipos de dados SIMD foram introduzidos à arquitetura x86 como parte das extensões do conjunto de instruções para otimizar o desempenho de aplicações de multimídia. O conceito básico é que múltiplos operandos são agrupados em um único item de memória referenciado e que esses múltiplos operandos são operados em paralelo. Os tipos são os seguintes:</p>

                <ul>
                    <li>Byte agrupado e inteiro de byte agrupado: bytes agrupados em uma quadword de 64bits ou double 64bits ou double quadword de 128bits, interpretada como um campo de bit ou como um bit inteiro;</li>

                    <li>Palavra agrupada e inteiro de palavra agrupada: palavras de 16bits agrupados em uma quadword de 64bits ou double quadword de 128bits, interpretada como um campo de bit ou como um inteiro;</li>
                    <li>Doubleword agrupado e inteiro de doubleword agrupado: doublewords de 32bits agrupados em uma quad word de 64bits ou double quadword de 128bits, interpretada como um campo de bit ou como um inteiro;</li>

                    <li>Quadword agrupado e inteiro de quadword agrupado: duas quadwords de 64bits qgrupadas em uma double quadword de 128bits, interpretada como um campo de bit ou como um inteiro;</li>

                    <li>Ponto flutuante de precisão simples agrupado e ponto flutuante de precisão dupla agrupado: quatro valores de ponto flutuante de 32bits ou dois valores de ponto flutuante de 64bits agrupados em uma double quadword de 128bits.</li>
                </ul>
            </section>
            <section>
                <h2>
                    4 – Explique os tipos de Operações possíveis em um
                    computador.
                </h2>
                <ul>
                    <li>Transferência de dados:  Especifica o local dos operandos de origem e destino, a extensão dos da dos e o modo de endereçamento para cada operando;</li>

                    <li>
                        Aritmética:  A  maioria  das  máquinas  oferece  operações  aritméticas  básicas  de  adição,  sub tração, multiplicação  e  divisão.  São  invariavelmente  fornecidas  para  números  inteiros  com  sinal.  Normalmente, elas  também  são  fornecidas  para  números  de  ponto  flutuante  e  decimal  agrupado.  Outras  o perações possíveis incluem uma série de instruções de único operando, por exemplo:
                        <ul>
                            <li>
                                Absolute:  apanha  o  valor  absoluto  do   operando,  
                            </li>
                            
                            <li>
                                negate:  inverte  o  sinal  do  operando,
                            </li>

                            <li>
                                incremente:  soma  1 ao  operando 
                            </li>
                            <li>
                                decrement:  subrai  1  do   operando.  
                            </li>
                            
                        </ul> 

                        <p>A  execução  de  uma  instrução  aritmética  pode  envolver operações de transferência de dados  para posicionar operandos para entrada na ALU e entregar na saída da ALU.</p>
                    </li>

                    <li>
                        Lógicas:  Operações  para  manipular  bits  individuais  de  uma  pala vra  ou   outras  unidades  endereçáveis, normalmente  conhecidas  como  “bit  twiddli ng”.  São  baseadas  e m  operações  booleanas.  Algu mas  das operações  lógicas  básicas  são:  NOT(inverte  um  b it),  AND,OR  e  Exclusive  OR  (XOR)  são  as  funções lógicas mais comuns com dois operandos. Equal é um teste binário útil; 
                    </li>

                    <li>
                        Conversão:  Instruções  de  conversão  são  aquelas  que  mudam  o   formato  ou  operam  sobr e  o  fo rmato  dos dados.  Ex. con versão de  decimal  para  binário.  Um exemplo  de  uma  instrução  de ed ição mais  complexa  é a ins trução Translate  (TR) do EAS/3 90. Essa  instrução  pode ser u sada para  converter um  código  de 8bits para outro e utiliza 3 operandos: TR R1(L), R2;
                    </li>

                    <li>
                        Entrada  e  sa ída:  As  instruções  de  entrada  e  s aída,  possuem  diversas  técnicas  que  podem  s er  usadas, incluindo  E/S  programada,  independente,  E/S  programada  mapeada  na  me mória,  DMA  e  o  uso  de  um processador  de  E/S.  Muitas  implementações  ofe recem  a penas  algumas  instruções  de  E/S,  com  ações específicas ditadas por parâmetros, códigos ou palavras de comando. -Controle  de  sistema:  São  aquelas  que  podem  ser  executadas  apenas  e nquanto  o  processador  está  em um  c erto  estado  p rivilegiado  ou  es tá  executando  um  programa   em  uma  área  privilegiada  especial  da memória.  Normalmente,  essas  instruções  são  res ervadas  para  o  uso  do  sistema  operacional.  Alguns exemplos  de  operações  de  controle  são:  Uma  instrução  de  c ontrole  do  sistema  pode  ler  ou  alterar  um registrador  de  controle;  outro  exemplo  é  u ma  instrução  para  ler  ou  modificar  uma  chave  de   proteção  de armazenamento,  c omo  a  que  é  usada  no  sistema  de  memória  do  EAS/390.  Outro  e xemplo  é  o  acesso para processar blocos de controle em um sistema multiprogramado; 
                    </li>

                    <li>
                        Transferência  de  controle:  Uma  fração  significativa  das  instruções  em  um  programa  tem  como  função mudar  a  sequência  de  execução  de  instruções.  Para  essas  instruções,  a  operação  realizada  pelo processador é atualizar  o contador de  programa para conter o endereço de alguma instrução  na memória. Os mais importantes motivos das operações de transferência de controle são: 
                        <ol>
                            <li>
                                Loop  no  programa  para  processar  uma  sequência  de  instruções  repetidamente,  para  que  todos  os dados sejam processados, ao invés de escrever cada instrução separadamente; 
                            </li>
                            <li>
                                Para uma tomada de decisão; 
                            </li>
                            <li>
                                Mecanismos  pa ra  dividir  a  tarefa  em  pedaços  menores  para  que  possam  ser  trabalhadas  uma  de  cada vez. 
                            </li>
                        </ol>
                    </li>
                </ul>
            </section>
            <section>
                <h2>5 – Explique as características dos processadores CISC.</h2>
                <p> CISC  (Complex  Instruction  Set  Computer,  ou,  em  um a  tradução  literal,  “Computador  com  um Conjunto Complexo de Instruções”): é um processador capaz de executar centenas de  instruções  complexas  diferentes  sendo,  assim,  extremamente  versátil.  Exemplos  de  processadores  CISC são  os  386  e  os  486  da  Intel.  Os  processadores  baseados  na  computação  de  conjunto  de  instruções complexas  contêm  uma  micro  programação,  ou  seja,  um  conjunto  de  códigos  de  instruções  que  são gravados  no  processador,  permitindo-lhe  receber  as  instruções  dos  programas  e  executá‐las,  utilizando as instruções contidas na sua micro programação. <b>Resumidamente:</b> </p>
                
                <ul>
                    <li>
                        Menos registradores
                    </li>
                    
                    <li>
                        Mais opcodes(através de micro-códigos)
                    </li>
                    
                    <li>
                        Mais lento
                    </li>
                </ul>
            </section>
            <section>
                <h2>6 – Explique as características dos processadores RISC.</h2>
                
                <p>Reduced  Ins truction  Set  Comp uter  ou  Computador  co m  um  Conjunto  Reduzido  de  Instruções (RISC),  é   uma  linha  de  arquitetura  de  c omputadores  que  favorece  um  conjunto  simples  e  pequeno  de instruções  que  levam  aproximadamente  a  mesma  quantidade  d e  tempo  para   serem  executadas.</p>

                <p>Como exemplo  de  aplicação  dessa  arquitetura  são   DEC  Alpha,  SPARC,  MIPS,  e  PowerPC.  O  tipo   de microprocessador  mais  largamente  usado  em  desktops,  o  x86,  é  mais  CISC  do  que  RISC,  embora  chips mais  novos  traduzam  instruções  x86  baseadas  em  arquitetura  CISC  em  formas  baseadas  em  arquitetura RISC  mais  simples,  utilizando  prioridade  de  execução.   Os  processadores  baseados  na  computação  de conjunto  de  instruções  reduzido  não  tem  microprogramação,  as  instruções  são  executadas  diretamente pelo hardware. Como característica, esta arquitetura, além de não ter microcódigo, tem o conjunto de instruções reduzido, bem como baixo nível de complexidade. <b>Resumidamente:</b> </p>
                
                <ul>
                    <li>
                        Muitos registradores
                    </li>
                    
                    <li>
                        Menos opcodes
                    </li>
                    
                    <li>
                        Mais rápido
                    </li>
                    
                    <li>
                        Foco no uso de pipelines
                    </li>
                </ul>
            </section>
            <section>
                <h2>
                    7 - Explique as características dos processadores Híbridos
                    CISC-RISC.
                </h2>

                <p>As características dos processadores são hibridas por simples questão de performance. Como na arquitetura CISC é que já temos muitas das instruções guardadas no  próprio processador, o que facilita o trabalho  dos  programadores, que já dispõe de praticamente todas as instruções que serão usadas em seus  programas.  Internamente,  o  processador  processa  apenas  instruções  simples.  Estas instruções  internas,  variam  de  processador  para  processador,  são  como  uma  luva,  que  se  adapta  ao projeto  do  chip.  Sobre  estas  instruções  internas,  temos  um  circuito  decodificador,  que  converte  as instruções complexas  utilizadas pelos  programas em  várias instruções simples que  podem ser  entendidas pelo  processador.  Estas  instruções  complexas  sim,  são  iguais  em  todos  os   processadores  usados  em micros  PC.  O  conjunto  básico  de  instruções  usadas  em  micros  PC  é chamado  de  conjunto  x86.  Este conjunto  é composto  por  um total  de  187   instruções,  que  são  as  utilizadas por  todos os programas.  Além deste  conjunto  principal,  alguns  processadores  trazem  também  instruções  alternativas,  que  permitem  aos programas  executar  algumas  tarefas  mais  rapidamente  do  que  seria  possível  usando  as  instruções  x86 padrão. <b>Resumidamente: </b></p>

                <ul>
                    <li>Sets de instruções complexos, que são decodificados em instruções simples</li>
                    <li>Alto desempenho</li>
                    <li>Conjunto base de instruções(x86)</li>
                    <li>
                        Podem estender o conjunto básico através de algumas técnologias como:
                        <ul>
                            <li>MMX</li>
                            <li>3D-NOW</li>
                            <li>SSE</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h2>
                    8 – Explique, utilizando as características do ciclo de
                    execução de instrução, Pipeline.
                </h2>
                <p>A pipeline  é uma  forma de  organizar o  funcionamento da  CPU criada  com o  intuito de melhorar o  desempenho  da  mesma.  Nela,  ao   invés  de  uma  instrução  esperar  que  a  instrução  anterior  seja executada para que então ela seja executada, a instrução é dividida em:</p> 

                <ul>
                    <li>
                        Buscar instrução(FI, do inglês Fetch Instruction): Ler a próxima instrução esperada em um buffer;
                    </li>

                    <li>
                        Decodidficar instrução (DI): determinar o opcode e os especificadores dos operandos; 
                    </li>

                    <li>
                        Calcular  operandos  (CO):  calcular  o  endereço  efetivo  de  cada  operando  de  origem,  que  pode envolver endereçamento por deslocamento, registrador indireto ou outras formas de cálculo de endereço;
                    </li>

                    <li>
                        Obter  operandos  (FO:  Fetch  operands):  obter  cada  operando  da  memória.  Operandos  que  se  encontram nos registradores, não precisam ser lidos pela memória; 
                    </li>

                    <li>
                        Executar  instrução  (EI):  efetuar  a  operação  indicada  e  armazenar o resultado,  se  houver  na  posição operando de destino especificada; 
                    </li>

                    <li>
                        Escrever operando (Write operands): Armazenar o resultado na memória.
                    </li>
                </ul>
                
                
            </section>

            <section>
                <h2>
                    9 – Explique os tipos de tratamento de saltos em Pipelines.
                </h2>

                <p> Múltiplos  fluxos:  Tem  dois  pipelines,  fazendo  uso  de  dois  fluxos.  Com  múltiplos  pipelines, existem  atrasos  no  acesso  aos  registradores  e  à  memória.  Instruções  de   desvio  a dicionais  podem  entrar no  pipeline  (ou  em  qualquer  dos  fluxos)  antes  que  a  decisão  de  desvio  original  seja  resolvida.  Cada  uma dessas instruções precisa de um fluxo adicional.</p>
                
                <ul>
                    <li>
                        <b>Busca  antecipada  do  alvo  do  desvio:</b>  Quando  um  desvio  condicional  é  reconhecido,  o  alvo  do  desvio  é lido  antecipadamente, além  da  instrução  que segue o  desvio.  Esse  alvo é  então  salvo  até que  a  instrução de desvio seja executada. Se o desvio for tomado, o alvo já foi obtido.
                    </li>

                    <li>
                        <b>Buffer  de   laço  de  repetição:</b>  Um  buffer  de  laço  de  repetição  é  uma  memória  pequena  e  extremamen te rápida  mantida  pelo estágio  pipeline  de busca  da  instrução e  que  contém  n  instruções  mais  recentemente lidas  na  sequência.  Se  um  desvio  está  para  ser  tomado,  o  hardware  primeiro  verifica  se  o   alvo  do  desvio já está  no buffer.  Se estiver, a próxima instrução é  obtida do buff r. O buffer  de laço de  repetição possui 3 benefícios:

                        <ul>
                            <li>
                                Com o uso de busca an tecipada, o buffer conterá algumas instruções em sequência na frente do endereço  da  instrução  atual,  assim  as  instruções  obtidas  na  sequência  estarão  disponíveis  sem  o  tempo usual de acesso à memória.
                            </li>

                            <li>
                                Se  um  desvio  para   um  alvo  estiver  apenas  algumas  posições  à frente do  endereço  da  instrução de desvio, o alvo já estará no buffer.
                            </li>

                            <li>
                                É particularmente bem adaptada para lidar com lações ou interações.
                            </li>
                        </ul>
                    </li>
                    <li>
                        <b>Previsão  de  desvio:</b>  Várias  técnicas  podem  ser  usadas  para  prever  se  um  desvio  será  tomado.  Entre  as mais comuns estão as seguintes:   
                        
                        <ul>
                            <li>
                                <b>Previsão nunca tomada:</b> Nunca vai ter salto;
                            </li>
                            
                            <li>
                                <b>Previsão sempre tomada:</b> Sempre atrasa 1 tempo pipeline;
                            </li>

                            <li>
                                <b>Previsão  por  opcode  (mais  utilizada):</b>  O  processador  assume  que  o  desvio  será  feito  para determinados  opcodes  d e  desvio  e  não  para  outros.  Taxas  de  sucesso  superiores  a  75%  com  esta estratégia.   
                            </li>

                            <li>
                                <b>Chave  tomada/não  tomada:</b>  As  estratégias  dinâmicas  tentam  melhorar  a  precisão  da  previsão armazenando  um  histórico  de  instruções  de  desvios  condicionais  de  programa .  Um  ou  mais  bits  podem ser  associados  com  cada  instrução  de  desvio  condicional  que  reflete  o  histórico  recente  da  instrução. Estes  bits  são  conhecidos  como  uma  chave  tomada/não  tomada  que  direciona  o  processador  a  tomar uma determinada decisão na próxima  vez que a instrução for encontrada.   
                            </li>

                            <li>
                                <b>Tabela de histórico de desvio:</b>  é  uma  pequena  memória  cache  associada  com  o  estágio  de leitura  da  instrução  do  pipeline.  Cada  entrada  da  tabela  consiste  de  três  elementos:  o  endereço  da instrução  de  desvio,  algum  número  de  bits  de  histórico  que  guardam  o  estado  de  uso  dessa  instrução  e informação  sobre  a  instrução  alvo.  Outra  possibilidade  é  que  o  terceiro  campo  contenha  a  instrução  alvo em  si.  A  negociação  é  clara:  armazenar  o  endereço  do  alvo  necessita  de   uma  tabela  menor,  porém,  um tempo maior para obter a instrução se comparado com armazenar a instrução alvo.
                            </li>
                        </ul>
                    </li>
                </ul>
                    
                    
                    
                    
                    
            </section>
            <section>
                <h2>10 – Explique Superpipeline.</h2>
            </section>
            <section>
                <h2>11 – Explique Superescalar.</h2>
            </section>
            <section>
                <h2>12 – Explique as limitações de um sistema Superescalar.</h2>
            </section>
            <section>
                <h2>
                    13 – Explique as possibilidades para Multiprocessadores
                    Simétricos.
                </h2>
            </section>
            <section>
                <h2>14 – Explique a Lei de Pollack.</h2>
            </section>
            <section>
                <h2>
                    15 – Explique a organização Multicore para os Principais
                    Processadores.
                </h2>
            </section>
        </article>
    </body>
</html>
